"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _encryption = require("blockstack/lib/encryption");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const errorMessage = message => {
  throw new Error(`Error when validating: ${message}`);
};

let Validator =
/*#__PURE__*/
function () {
  function Validator(db, attrs) {
    _classCallCheck(this, Validator);

    _defineProperty(this, "db", void 0);

    _defineProperty(this, "attrs", void 0);

    _defineProperty(this, "previous", void 0);

    this.db = db;
    this.attrs = attrs;
  }

  _createClass(Validator, [{
    key: "validate",
    value: async function validate() {
      this.validatePresent('_id');
      await this.fetchPrevious();
      await this.validateSignature();
      await this.validatePrevious();
      await this.validateUpdatedAt();
      return true;
    }
  }, {
    key: "fetchPrevious",
    value: async function fetchPrevious() {
      const {
        _id
      } = this.attrs;
      this.previous = await this.db.findOne({
        _id
      });
    }
  }, {
    key: "validateSignature",
    value: async function validateSignature() {
      const {
        signingKeyId
      } = this.attrs.userGroupId ? this.attrs : this.previous || this.attrs;
      const {
        radiksSignature,
        updatable,
        updatedAt,
        _id
      } = this.attrs;

      if (updatable === false) {
        return true;
      }

      this.validatePresent('radiksSignature');
      this.validatePresent('signingKeyId');
      this.validatePresent('updatedAt');
      await this.signingKeyMatchesGroup();
      let signingKey;

      if (signingKeyId === 'personal') {
        const {
          publicKey
        } = this.previous || this.attrs;
        signingKey = {
          publicKey
        };
      } else {
        signingKey = await this.db.findOne({
          _id: signingKeyId
        });

        if (!signingKey) {
          errorMessage(`No signing key is present with id: '${signingKeyId}'`);
        }
      }

      const {
        publicKey
      } = signingKey;
      const message = `${_id}-${updatedAt}`;
      const isValidSignature = (0, _encryption.verifyECDSA)(message, publicKey, radiksSignature);

      if (!isValidSignature) {
        errorMessage('Invalid radiksSignature provided');
      }

      return true;
    }
  }, {
    key: "signingKeyMatchesGroup",
    value: async function signingKeyMatchesGroup() {
      if (this.attrs.userGroupId) {
        const userGroup = await this.db.findOne({
          _id: this.attrs.userGroupId
        });

        if (userGroup && userGroup.signingKeyId !== this.attrs.signingKeyId) {
          errorMessage('Signing key does not match UserGroup signing key');
        }
      }

      return true;
    }
  }, {
    key: "validatePrevious",
    value: async function validatePrevious() {
      if (this.previous && this.attrs.updatable === false) {
        errorMessage('Tried to update a non-updatable model');
      }
    }
  }, {
    key: "validateUpdatedAt",
    value: function validateUpdatedAt() {
      if (!this.previous) {
        return true;
      }

      if (typeof this.previous.updatedAt !== "number") {
        errorMessage("This model's previous `updatedAt` is not a number");
      }

      if (typeof this.attrs.updatedAt !== "number") {
        errorMessage("This model's `updatedAt` is not a number");
      }

      if (this.attrs.updatedAt <= this.previous.updatedAt) {
        errorMessage("Model's `updatedAt` has not been increased");
      }

      return true;
    }
  }, {
    key: "validatePresent",
    value: function validatePresent(key) {
      if (!this.attrs[key]) {
        errorMessage(`No '${key}' attribute, which is required.`);
      }
    }
  }]);

  return Validator;
}();

var _default = Validator;
exports.default = _default;
module.exports = exports.default;